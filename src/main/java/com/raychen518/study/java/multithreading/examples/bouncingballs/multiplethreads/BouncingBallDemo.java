package com.raychen518.study.java.multithreading.examples.bouncingballs.multiplethreads;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.EventQueue;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JPanel;

/**
 * <pre>
 * This class is used to make a demo about bouncing balls (generated by multiple threads).
 * 
 * -------------------------------------
 * Steps to Start a Thread
 * -------------------------------------
 * 1. Construct a runnable object.
 * 2. Allocate a new thread for that runnable object.
 * 3. Start the allocated thread.
 * 
 * Example
 * -	// Step #1
 * -	Runnable runnable = new Runnable() {
 * -
 * -		@Override
 * -		public void run() {
 * -			// ...
 * -		}
 * -
 * -	};
 * -
 * -	// Step #2
 * -	Thread thread = new Thread(runnable);
 * -
 * -	// Step #3
 * -	thread.start();
 * </pre>
 */
public class BouncingBallDemo {
	public static void main(String[] args) {
		EventQueue.invokeLater(new Runnable() {

			public void run() {
				JFrame frame = new BouncingBallFrame();
				frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
				frame.setVisible(true);
			}

		});
	}
}

/**
 * <pre>
 * This class represents a frame which is used to contain bouncing balls.
 * </pre>
 */
class BouncingBallFrame extends JFrame {

	private static final long serialVersionUID = -7103483292893063470L;

	private BallComponent ballComponent;

	public BouncingBallFrame() {
		setTitle("Bouncing Balls");

		ballComponent = new BallComponent();

		add(ballComponent, BorderLayout.CENTER);

		JPanel buttonPanel = new JPanel();

		// Add the "Start" button.
		addButton(buttonPanel, "Start", new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent actionEvent) {
				addBall();
			}

		});

		// Add the "Close" button.
		addButton(buttonPanel, "Close", new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent actionEvent) {
				System.exit(0);
			}

		});

		add(buttonPanel, BorderLayout.SOUTH);

		pack();
	}

	/**
	 * Add the specified button to its specified container, with its specified
	 * title set and its specified action listener added.
	 * 
	 * @param container
	 *            The specified button's container.
	 * @param title
	 *            The specified button's title.
	 * @param actionListener
	 *            The specified button's action listener.
	 */
	private void addButton(Container container, String title, ActionListener actionListener) {
		JButton button = new JButton(title);
		container.add(button);
		button.addActionListener(actionListener);
	}

	/**
	 * Add a bouncing ball.
	 */
	private void addBall() {
		Ball ball = new Ball();
		ballComponent.add(ball);

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Allocate a new thread for the newly added ball, to make the ball
		// bounce.
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Construct the runnable for a bouncing ball.
		// The java.lang.Runnable interface should be implemented by any class
		// whose instances are intended to be executed by a thread.
		Runnable runnable = new BallRunnable(ball, ballComponent);

		// Allocate a new thread for the specified runnable object.
		// The "run()" method of the specified runnable object will be invoked
		// when the thread is started.
		Thread thread = new Thread(runnable);

		// Start the thread.
		// This thread will then be caused to begin its execution, and JVM will
		// call the "run()" method of this thread.
		// The result of this thread's execution is that 2 threads are running
		// concurrently.
		// 1. The current thread (which returns from the call to the "start()"
		// method.
		// 2. The other thread (which executes its "run()" method.
		thread.start();
	}
}

/**
 * <pre>
 * This class represents a runnable that animates a bouncing ball.
 * </pre>
 */
class BallRunnable implements Runnable {

	/**
	 * How many steps a bouncing ball should move before it stops.
	 */
	private static final int MOVE_STEPS = 1000;

	/**
	 * The delay (unit: millisecond) after each move of a bouncing ball.
	 */
	private static final int MOVE_DELAY = 3;

	private Ball ball;
	private Component ballComponent;

	/**
	 * Construct the runnable.
	 * 
	 * @param ball
	 *            The ball to bounce.
	 * @param ballComponent
	 *            The component in which the ball bounces.
	 */
	public BallRunnable(Ball ball, Component ballComponent) {
		this.ball = ball;
		this.ballComponent = ballComponent;
	}

	@Override
	public void run() {
		try {
			// Animate a bouncing ball.
			for (int i = 1; i <= MOVE_STEPS; i++) {
				ball.move(ballComponent.getBounds());
				ballComponent.repaint();

				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// Cause the currently executing thread to sleep for the
				// specified number of milliseconds.
				// Without this sleep, all the ball's moves will be done
				// instantly, causing the move process cannot be viewed clearly.
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				Thread.sleep(MOVE_DELAY);
			}
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

}
